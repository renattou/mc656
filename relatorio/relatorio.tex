\documentclass[a4paper,11pt]{article}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amssymb}

\title{Relatório MC658}
\author{Tiago L. Gimenes - 118827\\
        Renato L. Vargas - 118557}

\begin{document}
\maketitle

\section*{Introdução}
Neste trabalho tentamos atacar o problema de ordenação de cenas através de três
abordagens diferentes. Primeiramente com algoritmos exatos (PLI e B\&B) e em seguida
uma metaheurística (algoritmo genético). O algoritmo genético se mostrou muito bom
em 10/11 experimentos, errando em, ao máximo, 50 unidades. O algoritmo de B\&B
proposto se mostrou capaz de resolver instancias relativamente grandes (com 18 cenas)
, equanto que o PLI se mostrou como um bom validador de resultados para os outros
algoritmos.

\section{Metaheurística}
TODO

\section{Modelo PLI}
\subsection{Entrada e constantes}
Seja $n$ a quantidade de cenas, $m$ a quantidade de atores e $b$ a quantidade de
dias. Como somente uma cena é gravada por dia, temos que $n = b$. Sejam $N=\{1..n\}$,
$M = \{1..m\}$ e $B=\{1..b\}$ os conjuntos que representam as cenas, atores e dias
respectivamente. Da entrada do problema, podemos definir as seguintes constantes:

\begin{equation}
  t_{ij} = \begin{dcases*}
              1 & se ator $i \in M$ está na cena $j \in N$ \\
              0 & se não.
           \end{dcases*}
  \label{tij}
\end{equation}

\begin{equation}
  c_{i} = \begin{dcases*} k \in \mathbb{N} & salário diário do ator $i \in M$ \end{dcases*}
\end{equation}

\begin{equation}
  s_{i} = \begin{dcases*} \sum_{j \in N} t_{ij} \in \mathbb{N} & número de cenas que o ator $i \in M$ participa\end{dcases*}
\end{equation}

\subsection{Variáveis}
Para formular esse problema, utilizaremos as seguintes variáveis:

\begin{equation}
  p_{jl} = \begin{dcases*}
              1 & se cena $j \in N$ está no dia $l \in B$ \\
              0 & se não.
           \end{dcases*}
  \label{pjl}
\end{equation}

\begin{equation}
  x_{il} = \begin{dcases*}
              1 & se ator $i \in M$ está no dia $l \in B$ \\
              0 & se não.
           \end{dcases*}
  \label{xil}
\end{equation}

\begin{equation}
  e_{i} = \begin{dcases*} k \in B & dia em que ator $i \in M$ começa a trabalhar \end{dcases*}
  \label{ei}
\end{equation}

\begin{equation}
  d_{i} = \begin{dcases*} k \in B & dia em que ator $i \in M$ termina de trabalhar \end{dcases*}
  \label{di}
\end{equation}

\begin{equation}
  h_{i} = \begin{dcases*} k \in B & dias de espera do ator $i \in M$ \end{dcases*}
  \label{hi}
\end{equation}

Intuitivamente, as variáveis (\ref{pjl}) representam se uma cena está em certo dia
ou não, ou seja, ela representa a ordem das cenas. Visto que há uma variável para
cada par de índices $jl$, temos $O(n*b) = O(n^2)$ variáveis do tipo $p_{jl}$. As
variáveis do tipo (\ref{xil}) representam se um determinado ator fará uma cena
em um determinado dia. Neste caso, há $O(m*b) = O(m*n)$ variáveis do tipo $x_{il}$.

As variáveis do tipo (\ref{ei}) e (\ref{di}) representam, respectivamente, os dias em que o ator
começa e termina de participar das cenas, ou seja, elas marcam a participação
mais a esquerda e mais a direita de um ator em uma ordenação das cenas. Como há
uma variável de cada tipo para cada ator, há $O(m)$ variáveis deste tipo no programa.

As variáveis (\ref{hi}) representam os dias de espera de um determinado ator, como
descrito no enunciado. Há também $O(m)$ variáveis deste tipo no programa linear.
\subsection{Restrições}
Há basicamente sete conjuntos de restrições abaixo. Cada restrição pode ser encontrada
à esquerda do símbolo de chaves. À direita é mostrado o domínio das variáveis livres
e, logo após, é dada uma breve descrição da restrição:
\begin{equation}
  \sum_{j \in N} p_{jl} = 1 \begin{dcases*} \forall l \in B & Uma cena por dia \end{dcases*}
  \label{cena_dia}
\end{equation}

\begin{equation}
  \sum_{l \in B} p_{jl} = 1 \begin{dcases*} \forall j \in N & Um dia por cena \end{dcases*}
  \label{dia_cena}
\end{equation}

\begin{equation}
  \sum_{j \in N} t_{ij} p_{jl} = x_{il} \begin{dcases*} \forall i \in M, l \in B & ator está no dia se estiver na cena desse dia \end{dcases*}
  \label{actor_cene_day}
\end{equation}

\begin{equation}
  e_{i} \leq n + (l-n)x_{il} \begin{dcases*} \forall i \in M, l \in B & primeiro dia do ator \end{dcases*}
  \label{first_day}
\end{equation}

\begin{equation}
  d_{i} \geq lx_{il} \begin{dcases*} \forall i \in M, l \in B & último dia do ator \end{dcases*}
  \label{last_day}
\end{equation}

\begin{equation}
  d_{i} - e_i + 1 - s_i = h_i \begin{dcases*} \forall i \in M & dias ociosos \end{dcases*}
  \label{wait}
\end{equation}

\begin{equation}
  \sum_{i=1}^j p_{in} \leq 1 - p_{j1} \begin{dcases*} \forall j \in N & quebra de simetria \end{dcases*}
  \label{sem_simetria}
\end{equation}

As restrições (\ref{cena_dia}) e (\ref{dia_cena}) fazem com que haja somente uma
cena por dia e um dia por cena respectivamente. Há um total de $O(n)$ restrições
de cada tipo

As restrições (\ref{actor_cene_day}) realizam a semântica das variáveis (\ref{xil}).
Note que, como há somente uma cena por dia e que as variáveis (\ref{pjl}) e (\ref{tij})
são booleanas, o resultado da soma do lado esquerdo também é booleano. Há $O(m*n)$
restrições desse tipo.

As restrições (\ref{first_day}) e (\ref{last_day}) contam, respectivamente, o
primeiro e último dia em que o ator gravará uma cena. Note que, como há $O(n)$
restrições desse tipo para cada ator, essas restrições são equivalentes a um
mínimo para o caso de (\ref{first_day}) e a um máximo para o caso de (\ref{last_day}).
Há um total de $O(m*n)$ restrições desse tipo.

Restrições do tipo (\ref{wait}) contabilizam os dias ociosos de cada ator, havendo
somente $O(m)$ restrições desse tipo.

Somente com as restrições de \ref{cena_dia} à \ref{wait}, uma solução do programa
linear, é solução do problema de ordenação de cenas. As retrições \ref{sem_simetria}
entram com o intuito de quebrar simetrias na solução e então, fazer com que o PLI
evite revisar algumas soluções, aumentando o tamanho das instâncias resolvidas pelo PLI.
Essas restrições evitam soluções espelhadas em torno da cena cental. Há $O(n)$ restrições
deste tipo.

\subsection{Função objetivo}
A função objetivo pode ser formulada facilmente em função das variáveis e constantes
seguindo o enunciado:

\begin{equation}
  \sum_{i \in M} c_i h_i
\end{equation}

\subsection{Formulação final}
A formulação final consta com todas as $O(nm + n^2)$ variáveis e as $O(nm)$
restrições descritas acima.

\section{Branch and Bound}
A implementação do algoritmo de \textit{branch and bound} seguiu os passos principais
descritos no enunciado, com as diferenças descritas nesta seção.

\subsection{Inicialização da solução primal}
Opostamente à dica do enunciado de se fazer uma busca em profundidade na árvore
de soluções, para se achar uma solução primal inicial, utilizamos a metaheurística
implementada neste trabalho (algoritmo genético). A metaheurística é executada
por 100ms antes da execução do algoritmo de \textit{branch and bound}.

Utilizamos a metaheurística com o intuito de que ela poderia proporcionar uma
boa solução primal com relativamente pouco esforço computacional. Essa premissa
se mostrou válida em alguns casos, onde a solução encontrada pela metaheurística
não estava tão distante da solução ótima, mas se mostrou falsa em outros casos
onde a metaheurística ficou presa em mínimos locais.

\subsection{Exploração da arvore de soluções}
A árvore de soluções foi explorada através de uma estratégia de \textit{best bound},
onde um \textit{heap} foi utilizado para a manutenção da fila de prioridade. A prioridade
desta fila é medida através do menor limitante inferior de um nó da árvore, com empates favorecendo
nós mais profundos.

Também com o intuito de se podar mais nós, quando um nó é explorado, para cada filho,
a solução parcial é completada através de um algoritmo guloso rápido para tentar se obter
limitantes primais melhores. Caso o custo da solução gulosa seja igual à do limitante
inferior para aquele nó, não é necessaria a exploração deste ramo. Caso a solução gulosa seja melhor
do que a melhor solução encontrada até o momento, a melhor solução é atualizada
para a gulosa.

\subsection{Heurística para obtenção do empacotamento $Q$}
Seguindo a dica do enunciado de utilizar um algoritmo guloso rápido com o intuito
de maximizar o tamanho do empacotamento $Q$, propomos um algoritmo que tenta
adicionar à $Q$ cenas com o menor número de atores possível, minimizando a probabilidade
de conflito de atores com outras cenas de $Q$, maximizando o empacotamento.

Sem perda de generalidade, supomos que estamos calculando o
limitante $k_3$, logo o conjunto de atores válidos a ser procurado o empacotamento
de cenas $Q$ é $B_E(P)$. Seja $C$ o conjunto de cenas que ainda não foram programadas nem à esquerda nem
à direita na solução parcial.

Primeiramente começamos a calcular o custo de cada cena $c \in C$, de acordo com
o enunciado, somando os custos dos atores de $B_E(P)$ presentes na cena $c$. Também
é calculado nessa parte quantidade de atores de $B_E(P)$ na cena $c$.

Com os custos e quantidade de atores em cada cena calculados, começamos por ordená-las
em ordem não decrescente de frequência de aparição dos atores, eliminando
as cenas com custo igual a zero. Percorremos então o vetor de cenas ordernado,
adicionando cenas à $Q$ sempre que possível, ou seja, tal que os atores presentes
na cena atual não estejam ainda presentes em nenhuma outra cena de $Q$, respeitando as condições
do enunciado.

Por fim, o empacotamento $Q$ é ordenado em ordem não crescente de custo, e retornado.

Mudando o conjunto $B_E(P)$ por $B_D(P)$ podemos calcular o empacotamento para o
limitante $k_4$ utilizando o mesmo algoritmo descrito acima.

\section{Experimentos}
Os experimentos a seguir foram executados em um Intel Core i7-4700MQ 2.40GHz com
16GB de memória RAM e compilados com GCC 7.2.0.

\subsection{Metaheurística}
\begin{table}[h]
  \centering
  \begin{tabular}{c & c & c}
    Dataset & Função Objetivo & Tempo de execução(s) \\
    e0806.txt & 4   & 30 \\
    e1006.txt & 12  & 30 \\
    e1008.txt & 74  & 30 \\
    e1010.txt & 451 & 30 \\
    e1206.txt & 26  & 30 \\
    e1208.txt & 69  & 30 \\
    e1210.txt & 115 & 30 \\
    e1211.txt & 113 & 30 \\
    e1410.txt & 120 & 30 \\
    e1411.txt & 137 & 30 \\
    e1808.txt & 145 & 30 \\
  \end{tabular}
  \caption{Resultados para a Metaheurística(algoritmo genético)}
  \label{meta}
\end{table}

\subsection{PLI}
\begin{table}[h]
  \centering
  \begin{tabular}{c & c & c & c & c}
    Dataset & Função Objetivo & Lim. dual & Nós explorados  & Tempo de execução(s) \\
    e0806.dat & 4   & 4  & 75     & 0.02   \\
    e1006.dat & 12  & 12 & 1645   & 0.79   \\
    e1008.dat & 24  & 24 & 2999   & 1.72   \\
    e1010.dat & 51  & 51 & 21849  & 21.26  \\
    e1206.dat & 22  & 22 & 67251  & 63.17  \\
    e1208.dat & 80  & 0  & 105249 & 180.01 \\
    e1210.dat & 81  & 4  & 104101 & 180.01 \\
    e1211.dat & 113 & 0  & 78081  & 180.01 \\
    e1410.dat & 125 & 0  & 81965  & 180.02 \\
    e1411.dat & 177 & 0  & 69353  & 180.01 \\
    e1808.dat & 191 & 0  & 67057  & 180.02 \\
  \end{tabular}
  \caption{Resultados para o PLI}
  \label{pli}
\end{table}

\subsection{Branch and Bound}
\begin{table}[h]
  \centering
  \begin{tabular}{c & c & c & c & c}
  Dataset & Função Objetivo & Lim. dual & Nós explorados  & Tempo de execução(s) \\
  e0806.txt & 4   & 4   & 75       & 0.10 \\
  e1006.txt & 12  & 12  & 1334     & 0.10 \\
  e1008.txt & 24  & 24  & 388      & 0.10 \\
  e1010.txt & 51  & 51  & 275      & 0.10 \\
  e1206.txt & 22  & 22  & 16672    & 0.18 \\
  e1208.txt & 69  & 69  & 69305    & 0.46 \\
  e1210.txt & 81  & 81  & 116069   & 0.76 \\
  e1211.txt & 104 & 104 & 15675    & 0.21 \\
  e1410.txt & 115 & 115 & 504148   & 3.62 \\
  e1411.txt & 132 & 132 & 256840   & 2.38 \\
  e1808.txt & 135 & 135 & 12127193 & 139.70 \\
  \end{tabular}
  \caption{Resultados para o Branch and Bound}
  \label{bnb}
\end{table}

\section{Conclusão}
TODO

\end{document}
